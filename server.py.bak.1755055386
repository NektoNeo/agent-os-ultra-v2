
import os, json, uuid, threading, subprocess, shlex, time, base64, tarfile, zipfile, re, io, hashlib, sqlite3
from pathlib import Path
from urllib.parse import urlparse
from typing import Optional, List, Dict, Any

from fastapi import FastAPI, HTTPException, Depends, Body, Query, Request, Response
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, FileResponse
from pydantic import BaseModel
from dotenv import load_dotenv
from bs4 import BeautifulSoup

APP_VERSION = "3.1.0"
load_dotenv(override=True)

TOKEN = os.getenv("GPT_BRIDGE_TOKEN", "")
PUBLIC_URL = (os.getenv("PUBLIC_URL", "") or "").strip()
PORT = int(os.getenv("PORT", "5173"))
ROOT = Path(__file__).parent.resolve()

def load_json_file(path: Path, default: Any) -> Any:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return default

CONFIG = load_json_file(Path("config.json"), {
    "allowed_apps": ["Safari","Google Chrome","Finder"],
    "allowed_url_domains": ["*"],
    "allowed_shortcuts": ["*"],
    "allow_key_injection": False,
    "allowed_exec_bins": ["git","node","npm","pnpm","yarn","python3","pip","ssh","scp","rsync","zip"],
    "workspace": "./workspace",
    "allow_fs_outside_workspace": False,
    "require_approval_for": []
})

def resolve_workspace(pth: str) -> Path:
    p = Path(pth).expanduser()
    # fallback away from sandbox paths
    if str(p).startswith("/mnt/"):
        return ROOT / "workspace"
    return p if p.is_absolute() else (ROOT / p)

WORKSPACE = resolve_workspace(CONFIG.get("workspace","./workspace"))
WORKSPACE.mkdir(parents=True, exist_ok=True)
ARTIFACTS = Path("artifacts"); ARTIFACTS.mkdir(exist_ok=True)

SECRETS_FILE = Path("secrets.json"); SECRETS_FILE.write_text(SECRETS_FILE.read_text(encoding="utf-8") if SECRETS_FILE.exists() else "{}", encoding="utf-8")
KV_FILE = Path("kv.json"); KV_FILE.write_text(KV_FILE.read_text(encoding="utf-8") if KV_FILE.exists() else "{}", encoding="utf-8")

# ----- Auth -----
security = HTTPBearer(auto_error=False)
def require_auth(creds: HTTPAuthorizationCredentials = Depends(security)):
    if not TOKEN:
        raise HTTPException(500, "Bridge token not set on server")
    token = creds.credentials if creds else None
    if not token or token != TOKEN:
        raise HTTPException(401, "Invalid token")

def require_approval(name: str, request: Request):
    required = set(CONFIG.get("require_approval_for", []))
    if name in required:
        if request.headers.get("X-Agent-Approve","").lower() not in ("1","yes","true","ok","approve"):
            raise HTTPException(403, "Approval required: add header X-Agent-Approve: yes")

# ----- FastAPI instance -----
app_kwargs = dict(title="Agent-OS Ultra v2 API", version=APP_VERSION)
if PUBLIC_URL: app_kwargs["servers"] = [{"url": PUBLIC_URL}]
app = FastAPI(**app_kwargs)

app.mount("/artifacts", StaticFiles(directory=str(ARTIFACTS)), name="artifacts")
actions_dir = Path("actions")
if actions_dir.exists(): app.mount("/actions", StaticFiles(directory=str(actions_dir)), name="actions")
web_dir = Path("web")
if web_dir.exists(): app.mount("/static", StaticFiles(directory=str(web_dir)), name="static")

# ----- Helper utils -----
def app_allowed(name: str) -> bool: return name in CONFIG.get("allowed_apps", [])
def shortcut_allowed(name: str) -> bool:
    allow = CONFIG.get("allowed_shortcuts", [])
    if "*" in allow: return True
    for pat in allow:
        if pat.endswith("*") and name.startswith(pat[:-1]): return True
        if name == pat: return True
    return False
def domain_allowed(url: str) -> bool:
    try: host = (urlparse(url).hostname or "")
    except Exception: return False
    allow = CONFIG.get("allowed_url_domains", [])
    for pat in allow:
        if pat == "*": return True
        if pat.startswith("*.") and host.endswith(pat[1:]): return True
        if host == pat: return True
    return False
def exec_allowed(cmd: str) -> bool:
    allow_bins = CONFIG.get("allowed_exec_bins", [])
    if "*" in allow_bins: return True
    first = shlex.split(cmd.strip())[0] if cmd.strip() else ""
    base = os.path.basename(first)
    return base in allow_bins
def ensure_parent(p: Path): p.parent.mkdir(parents=True, exist_ok=True)
def within_workspace(path: Path) -> bool:
    if CONFIG.get("allow_fs_outside_workspace", False): return True
    try: path.resolve().relative_to(WORKSPACE.resolve()); return True
    except Exception: return False
def now_ts() -> int: return int(time.time())

def secrets_load() -> Dict[str,str]:
    try: return json.loads(SECRETS_FILE.read_text(encoding="utf-8"))
    except Exception: return {}
def secrets_save(obj: Dict[str,str]): SECRETS_FILE.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")
def kv_load() -> Dict[str,Any]:
    try: return json.loads(KV_FILE.read_text(encoding="utf-8"))
    except Exception: return {}
def kv_save(obj: Dict[str,Any]): KV_FILE.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")

# ----- Schemas -----
class OpenApp(BaseModel): name: str
class ActivateApp(BaseModel): name: str
class OpenURL(BaseModel): url: str; app: Optional[str] = "Safari"
class Keystroke(BaseModel): keys: str; mods: List[str] = []
class KeyCode(BaseModel): code: int; mods: List[str] = []
class RunShortcut(BaseModel): name: str; input: Optional[str] = None
class FSRead(BaseModel): path: str; max_bytes: Optional[int] = 750000
class FSWrite(BaseModel): path: str; content: str; mode: str = "w"
class FSMkdir(BaseModel): path: str; exist_ok: bool = True
class FSList(BaseModel): path: str; recursive: bool = True
class FSArchive(BaseModel): path: str; format: str = "zip"
class ExecStart(BaseModel):
    cmd: str; cwd: Optional[str] = None; timeout: Optional[int] = None; env: Optional[Dict[str,str]] = None
class DeployCfg(BaseModel):
    host: str; user: str; key_path: Optional[str] = None; port: int = 22
    local_path: str = "./build"; remote_path: str = "~/site/public"; delete_remote: bool = False
class BrowserScrape(BaseModel):
    url: str; screenshot: bool = True; wait_ms: int = 1500; selector: Optional[str] = None
class CrawlCfg(BaseModel):
    start_url: str; max_pages: int = 30; max_depth: int = 2; same_host: bool = True
class TabularCfg(BaseModel):
    html: Optional[str] = None; url: Optional[str] = None
class SlackMsg(BaseModel):
    webhook_url: Optional[str] = None; alias: Optional[str] = None; text: str
class TGMsg(BaseModel):
    token: Optional[str] = None; chat_id: str; text: str
class NotionQuery(BaseModel):
    database_id: str; filter: Optional[dict] = None; sorts: Optional[List[dict]] = None
class AirtableList(BaseModel):
    base_id: str; table: str; max_records: int = 100
class SheetsRead(BaseModel):
    sheet_key: str; range: str
class SheetsWrite(BaseModel):
    sheet_key: str; range: str; values: List[List[str]]
class AIConfig(BaseModel):
    provider: str; model: Optional[str] = None; temperature: float = 0.2
class AIComplete(BaseModel):
    prompt: str; max_tokens: int = 512; system: Optional[str] = None
class AIEmbed(BaseModel):
    texts: List[str]; model: Optional[str] = None
class MemoryAdd(BaseModel):
    collection: str; texts: List[str]; metadatas: Optional[List[dict]] = None
class MemorySearch(BaseModel):
    collection: str; query: str; top_k: int = 5
class ScheduleAdd(BaseModel):
    name: str; cron: str; cmd: Optional[str] = None; url: Optional[str] = None
class QueueEnqueue(BaseModel):
    name: str; cmd: Optional[str] = None; url: Optional[str] = None

# Vision
class VisionText(BaseModel):
    text: str; lang: str = "eng"; click: bool = False
class VisionTemplate(BaseModel):
    template_b64: Optional[str] = None; template_path: Optional[str] = None; threshold: float = 0.85; click: bool = False
class VisionClick(BaseModel):
    x: int; y: int

# Audio
class TTSReq(BaseModel):
    text: str; voice: Optional[str] = None; rate: Optional[int] = None # words per minute
class STTReq(BaseModel):
    path: str; use_api: bool = False; lang: Optional[str] = None

# ----- Health -----
@app.get("/health")
def health():
    return {"ok": True, "version": APP_VERSION}

# UI & Shortcuts (same as v1, omitted here for brevity in comment)
@app.get("/shortcuts")
def shortcuts_list(_=Depends(require_auth)):
    res = subprocess.run(["shortcuts","list"], capture_output=True, text=True, check=False)
    names = [ln.strip() for ln in (res.stdout or "").splitlines() if ln.strip()]
    return {"ok": True, "items": names}

@app.post("/run_shortcut")
def run_shortcut(payload: RunShortcut, _=Depends(require_auth)):
    if not shortcut_allowed(payload.name): raise HTTPException(403, f"Shortcut not allowed: {payload.name}")
    cmd = ["shortcuts","run",payload.name] + (["-i", payload.input] if payload.input else [])
    try:
        res = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return {"ok": True, "output": (res.stdout or res.stderr or "").strip()}
    except subprocess.CalledProcessError as e:
        out = (e.stderr or e.stdout or str(e)).strip()
        raise HTTPException(400, f"shortcuts run failed: {out}")

@app.post("/open_app")
def open_app(payload: OpenApp, _=Depends(require_auth)):
    if not app_allowed(payload.name): raise HTTPException(403, f"App not allowed: {payload.name}")
    subprocess.run(["open","-a",payload.name], check=False); return {"ok": True}

@app.post("/activate_app")
def activate_app(payload: ActivateApp, _=Depends(require_auth)):
    if not app_allowed(payload.name): raise HTTPException(403, f"App not allowed: {payload.name}")
    script = f"tell application {payload.name!r} to activate"
    subprocess.run(["osascript","-e",script], check=False); return {"ok": True}

@app.post("/open_url")
def open_url(payload: OpenURL, _=Depends(require_auth)):
    if payload.app and not app_allowed(payload.app): raise HTTPException(403, f"App not allowed: {payload.app}")
    if not domain_allowed(payload.url): raise HTTPException(403, "URL domain not allowed")
    args = ["open"] + (["-a", payload.app] if payload.app else []) + [payload.url]
    subprocess.run(args, check=False); return {"ok": True}

@app.post("/keystroke")
def keystroke(payload: Keystroke, _=Depends(require_auth)):
    if not CONFIG.get("allow_key_injection", False): raise HTTPException(403, "Key injection disabled by config")
    mods = ", ".join([f"{m} down" for m in payload.mods]); using = f" using {{{mods}}}" if mods else ""
    script = f'tell application "System Events" to keystroke {payload.keys!r}{using}'
    subprocess.run(["osascript","-e",script], check=False); return {"ok": True}

@app.post("/keycode")
def keycode(payload: KeyCode, _=Depends(require_auth)):
    if not CONFIG.get("allow_key_injection", False): raise HTTPException(403, "Key injection disabled by config")
    mods = ", ".join([f"{m} down" for m in payload.mods]); using = f" using {{{mods}}}" if mods else ""
    script = f'tell application "System Events" to key code {payload.code}{using}'
    subprocess.run(["osascript","-e",script], check=False); return {"ok": True}

@app.post("/applescript/run")
def applescript_run(script: str = Body(..., embed=True), _=Depends(require_auth)):
    res = subprocess.run(["osascript","-e",script], capture_output=True, text=True, check=False)
    ok = res.returncode == 0
    return {"ok": ok, "stdout": (res.stdout or "").strip(), "stderr": (res.stderr or "").strip()}

@app.post("/jxa/run")
def jxa_run(script: str = Body(..., embed=True), _=Depends(require_auth)):
    res = subprocess.run(["osascript","-l","JavaScript","-e",script], capture_output=True, text=True, check=False)
    ok = res.returncode == 0
    return {"ok": ok, "stdout": (res.stdout or "").strip(), "stderr": (res.stderr or "").strip()}

# Clipboard & Screen
@app.get("/clipboard/get")
def clipboard_get(_=Depends(require_auth)):
    out = subprocess.run(["pbpaste"], capture_output=True, text=True)
    return {"ok": True, "text": out.stdout}

@app.post("/clipboard/set")
def clipboard_set(text: str = Body(..., embed=True), _=Depends(require_auth)):
    p = subprocess.Popen(["pbcopy"], stdin=subprocess.PIPE, text=True); p.communicate(input=text or ""); return {"ok": True}

@app.post("/screen/capture")
def screen_capture(full: bool = Body(True), path: Optional[str] = Body(None), _=Depends(require_auth)):
    ts = now_ts(); out = Path("artifacts") / (path or f"screen_{ts}.png")
    cmd = ["screencapture", "-x"]
    if full: cmd += [str(out)]
    else: cmd += ["-i", str(out)]
    subprocess.run(cmd, check=False)
    return {"ok": True, "file": f"/artifacts/{out.name}"}

# FS
@app.post("/fs/read")
def fs_read(payload: FSRead, _=Depends(require_auth)):
    p = Path(payload.path).expanduser(); 
    if not within_workspace(p): raise HTTPException(403, "Path outside workspace")
    data = p.read_bytes()
    if payload.max_bytes and len(data) > payload.max_bytes: data = data[:payload.max_bytes]
    try: return {"ok": True, "text": data.decode("utf-8")}
    except UnicodeDecodeError: return {"ok": True, "base64": base64.b64encode(data).decode()}

@app.post("/fs/write")
def fs_write(payload: FSWrite, _=Depends(require_auth)):
    p = Path(payload.path).expanduser(); 
    if not within_workspace(p): raise HTTPException(403, "Path outside workspace")
    ensure_parent(p); mode = payload.mode if payload.mode in ("w","a") else "w"
    with open(p, mode, encoding="utf-8") as f: f.write(payload.content)
    return {"ok": True}

@app.post("/fs/mkdir")
def fs_mkdir(payload: FSMkdir, _=Depends(require_auth)):
    p = Path(payload.path).expanduser(); 
    if not within_workspace(p): raise HTTPException(403, "Path outside workspace")
    p.mkdir(parents=True, exist_ok=payload.exist_ok); return {"ok": True}

@app.post("/fs/list")
def fs_list(payload: FSList, _=Depends(require_auth)):
    p = Path(payload.path).expanduser(); 
    if not within_workspace(p): raise HTTPException(403, "Path outside workspace")
    items = []
    if payload.recursive:
        for root, dirs, files in os.walk(p):
            for name in files: items.append(os.path.relpath(os.path.join(root,name), p))
    else: items = os.listdir(p)
    return {"ok": True, "items": items}

@app.post("/fs/archive")
def fs_archive(payload: FSArchive, _=Depends(require_auth)):
    p = Path(payload.path).expanduser(); 
    if not within_workspace(p): raise HTTPException(403, "Path outside workspace")
    ts = now_ts()
    out = Path("artifacts") / f"archive_{ts}.zip"
    with zipfile.ZipFile(out, "w", zipfile.ZIP_DEFLATED) as z:
        if p.is_dir():
            for rootd, dirs, files in os.walk(p):
                for name in files:
                    fpath = Path(rootd)/name; z.write(fpath, arcname=str(fpath.relative_to(p.parent)))
        else: z.write(p, arcname=p.name)
    return {"ok": True, "artifact": f"/artifacts/{out.name}"}

# Jobs (exec)
JOBS: Dict[str, Dict[str, Any]] = {}
def _stream_to_file(proc, log_path: Path):
    with open(log_path, "ab") as f:
        for line in iter(proc.stdout.readline, b""): f.write(line)
        proc.stdout.close()

@app.post("/exec/start")
def exec_start(payload: ExecStart, request: Request, _=Depends(require_auth)):
    if not exec_allowed(payload.cmd): raise HTTPException(403, "Command not allowed by allowed_exec_bins")
    require_approval("exec/start", request)
    cwd = Path(payload.cwd).expanduser() if payload.cwd else WORKSPACE
    if not within_workspace(cwd): raise HTTPException(403, "cwd outside workspace")
    ensure_parent(cwd / ".keep")
    job_id = uuid.uuid4().hex[:12]; log_path = Path("artifacts") / f"job_{job_id}.log"
    env = os.environ.copy(); 
    if payload.env: env.update(payload.env)
    proc = subprocess.Popen(["/bin/bash","-lc", payload.cmd], cwd=str(cwd), env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, bufsize=1)
    threading.Thread(target=_stream_to_file, args=(proc, log_path), daemon=True).start()
    JOBS[job_id] = {"pid": proc.pid, "status":"running", "started": time.time(), "log": str(log_path), "cwd": str(cwd)}
    def watcher(p, jid):
        rc = p.wait(); j = JOBS.get(jid, {}); j.update({"status":"success" if rc==0 else "failed","rc": rc,"finished": time.time()}); JOBS[jid]=j
    threading.Thread(target=watcher, args=(proc, job_id), daemon=True).start()
    return {"ok": True, "job_id": job_id, "log": f"/artifacts/{log_path.name}"}

@app.get("/exec/status")
def exec_status(job_id: str, _=Depends(require_auth)):
    j = JOBS.get(job_id); 
    if not j: raise HTTPException(404, "job not found")
    return {"ok": True, **j}

@app.get("/exec/logs")
def exec_logs(job_id: str, tail: int = 4000, _=Depends(require_auth)):
    j = JOBS.get(job_id); 
    if not j: raise HTTPException(404, "job not found")
    path = Path(j["log"]); data = path.read_bytes() if path.exists() else b""
    if tail>0 and len(data)>tail: data = data[-tail:]
    try: return {"ok": True, "text": data.decode("utf-8", errors="replace")}
    except: return {"ok": True, "base64": base64.b64encode(data).decode()}

@app.post("/exec/stop")
def exec_stop(job_id: str = Body(..., embed=True), _=Depends(require_auth)):
    j = JOBS.get(job_id); 
    if not j: raise HTTPException(404, "job not found")
    try: os.kill(j["pid"], 15); time.sleep(0.5)
    except Exception as e: return {"ok": False, "error": str(e)}
    j["status"]="stopped"; JOBS[job_id]=j; return {"ok": True}

# Git
class GitClone(BaseModel): repo: str; dest: Optional[str] = None
class GitBranch(BaseModel): name: Optional[str] = None
class GitCommit(BaseModel): message: str

def _git(cwd: Path, *args):
    return subprocess.run(["git", *args], cwd=str(cwd), capture_output=True, text=True, check=False)

@app.post("/git/clone")
def git_clone(cfg: GitClone, _=Depends(require_auth)):
    dest = Path(cfg.dest or WORKSPACE / Path(cfg.repo).stem); dest.parent.mkdir(parents=True, exist_ok=True)
    r = subprocess.run(["git","clone",cfg.repo,str(dest)], capture_output=True, text=True)
    ok = r.returncode == 0
    return {"ok": ok, "stdout": r.stdout, "stderr": r.stderr, "path": str(dest)}

@app.post("/git/status")
def git_status(path: str = Body(..., embed=True), _=Depends(require_auth)):
    cwd = Path(path).expanduser(); r = _git(cwd,"status","--porcelain","-b")
    return {"ok": True, "stdout": r.stdout, "stderr": r.stderr}

@app.post("/git/branch")
def git_branch(path: str = Body(..., embed=True), data: GitBranch = Body(None), _=Depends(require_auth)):
    cwd = Path(path).expanduser()
    if data and data.name: r = _git(cwd,"checkout","-b",data.name)
    else: r = _git(cwd,"branch","--show-current")
    return {"ok": r.returncode==0, "stdout": r.stdout, "stderr": r.stderr}

@app.post("/git/checkout")
def git_checkout(path: str = Body(..., embed=True), data: GitBranch = Body(None), _=Depends(require_auth)):
    cwd = Path(path).expanduser(); name = (data.name if data else None)
    if not name: raise HTTPException(400, "name required")
    r = _git(cwd,"checkout",name); return {"ok": r.returncode==0, "stdout": r.stdout, "stderr": r.stderr}

@app.post("/git/commit")
def git_commit(path: str = Body(..., embed=True), data: GitCommit = Body(...), _=Depends(require_auth)):
    cwd = Path(path).expanduser(); _git(cwd,"add","."); r = _git(cwd,"commit","-m",data.message)
    return {"ok": r.returncode==0, "stdout": r.stdout, "stderr": r.stderr}

@app.post("/git/pull")
def git_pull(path: str = Body(..., embed=True), _=Depends(require_auth)):
    cwd = Path(path).expanduser(); r = _git(cwd,"pull"); return {"ok": r.returncode==0, "stdout": r.stdout, "stderr": r.stderr}

@app.post("/git/push")
def git_push(path: str = Body(..., embed=True), _=Depends(require_auth)):
    cwd = Path(path).expanduser(); r = _git(cwd,"push"); return {"ok": r.returncode==0, "stdout": r.stdout, "stderr": r.stderr}

# Browser
@app.post("/browser/scrape")
def browser_scrape(cfg: BrowserScrape, _=Depends(require_auth)):
    try:
        from playwright.sync_api import sync_playwright
    except Exception:
        raise HTTPException(400, "Playwright not installed. pip install playwright && playwright install chromium")
    img_path = None; text = None; html = None
    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page(); page.goto(cfg.url, wait_until="domcontentloaded")
        if cfg.wait_ms: page.wait_for_timeout(cfg.wait_ms)
        if cfg.selector:
            try: text = page.inner_text(cfg.selector)
            except Exception: text = None
        html = page.content()
        if cfg.screenshot:
            fname = Path("artifacts") / f"scrape_{now_ts()}.png"; page.screenshot(path=str(fname), full_page=True); img_path = f"/artifacts/{fname.name}"
        browser.close()
    return {"ok": True, "html": html[:300000], "text": text, "screenshot": img_path}

@app.post("/browser/crawl")
def browser_crawl(cfg: CrawlCfg, _=Depends(require_auth)):
    import requests
    start = cfg.start_url; host = urlparse(start).hostname
    q = [start]; seen = set([start]); out = []
    while q and len(out) < cfg.max_pages:
        url = q.pop(0)
        try:
            r = requests.get(url, timeout=10, headers={"User-Agent":"agent-os"})
            if "text/html" not in r.headers.get("content-type",""): continue
            soup = BeautifulSoup(r.text, "lxml")
            title = (soup.title.string.strip() if soup.title else "")
            out.append({"url": url, "title": title})
            if len(out) >= cfg.max_pages: break
            for a in soup.select("a[href]"):
                href = a.get("href")
                if not href: continue
                if href.startswith("http"):
                    u = href
                elif href.startswith("/"):
                    u = f"{urlparse(url).scheme}://{urlparse(url).netloc}{href}"
                else:
                    continue
                if u in seen: continue
                if cfg.same_host and urlparse(u).hostname != host: continue
                seen.add(u)
                q.append(u)
        except Exception:
            continue
    return {"ok": True, "pages": out}

@app.post("/extract/tabular")
def extract_tabular(cfg: TabularCfg, _=Depends(require_auth)):
    import requests
    html = cfg.html
    if not html and cfg.url:
        r = requests.get(cfg.url, timeout=15)
        html = r.text
    if not html: raise HTTPException(400, "provide html or url")
    soup = BeautifulSoup(html, "lxml")
    tables = []
    for tbl in soup.select("table"):
        rows = []
        for tr in tbl.select("tr"):
            cells = [td.get_text(strip=True) for td in tr.select("th,td")]
            if cells: rows.append(cells)
        if rows: tables.append(rows)
    return {"ok": True, "tables": tables}

# Notifications (same as v1)
@app.post("/notify/show")
def notify_show(title: str = Body("Agent‑OS"), text: str = Body(...), _=Depends(require_auth)):
    subprocess.run(["osascript","-e",f'display notification {text!r} with title {title!r}'], check=False)
    return {"ok": True}

# Vision --- requires pytesseract/opencv + brew tesseract + optional 'cliclick' for clicking
@app.post("/vision/locate_text")
def vision_locate_text(v: VisionText, _=Depends(require_auth)):
    try:
        from PIL import Image
        import pytesseract
    except Exception:
        raise HTTPException(400, "Install OCR deps: pip install pillow pytesseract; brew install tesseract")
    # capture screen
    ts = now_ts(); img_path = Path("artifacts") / f"vision_{ts}.png"
    subprocess.run(["screencapture", "-x", str(img_path)], check=False)
    img = Image.open(img_path)
    from pytesseract import Output
    data = pytesseract.image_to_data(img, lang=v.lang or "eng", output_type=Output.DICT)
    target = v.text.strip().lower()
    hits = []
    for i, txt in enumerate(data.get("text", [])):
        if not txt: continue
        if target in txt.strip().lower():
            x, y, w, h = data["left"][i], data["top"][i], data["width"][i], data["height"][i]
            hits.append({"x": x, "y": y, "w": w, "h": h, "text": txt})
    clicked = False
    if v.click and hits:
        cx, cy = hits[0]["x"] + hits[0]["w"]//2, hits[0]["y"] + hits[0]["h"]//2
        if shutil.which("cliclick"):
            subprocess.run(["cliclick", f"c:{cx},{cy}"], check=False)
            clicked = True
        else:
            return {"ok": False, "error": "Install 'cliclick' via brew to enable clicking", "hits": hits, "screenshot": f"/artifacts/{img_path.name}"}
    return {"ok": True, "hits": hits, "clicked": clicked, "screenshot": f"/artifacts/{img_path.name}"}

@app.post("/vision/locate_template")
def vision_locate_template(v: VisionTemplate, _=Depends(require_auth)):
    try:
        import cv2, numpy as np
        from PIL import Image
    except Exception:
        raise HTTPException(400, "Install OpenCV & Pillow: pip install opencv-python-headless pillow")
    # screenshot
    ts = now_ts(); screen_path = Path("artifacts") / f"screen_{ts}.png"
    subprocess.run(["screencapture", "-x", str(screen_path)], check=False)
    screen = cv2.imread(str(screen_path), cv2.IMREAD_COLOR)
    if v.template_b64:
        import base64, io
        data = base64.b64decode(v.template_b64)
        nparr = np.frombuffer(data, np.uint8)
        tmpl = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    elif v.template_path:
        tmpl = cv2.imread(v.template_path, cv2.IMREAD_COLOR)
    else:
        raise HTTPException(400, "Provide template_b64 or template_path")
    res = cv2.matchTemplate(screen, tmpl, cv2.TM_CCOEFF_NORMED)
    _, max_val, _, max_loc = cv2.minMaxLoc(res)
    (x, y) = max_loc; h, w = tmpl.shape[:2]
    ok = max_val >= (v.threshold or 0.85)
    if v.click and ok and shutil.which("cliclick"):
        cx, cy = x + w//2, y + h//2
        subprocess.run(["cliclick", f"c:{cx},{cy}"], check=False)
    return {"ok": ok, "score": float(max_val), "rect": {"x": int(x), "y": int(y), "w": int(w), "h": int(h)}, "screenshot": f"/artifacts/{screen_path.name}"}

@app.post("/vision/click_at")
def vision_click_at(c: VisionClick, _=Depends(require_auth)):
    if shutil.which("cliclick"):
        subprocess.run(["cliclick", f"c:{c.x},{c.y}"], check=False)
        return {"ok": True}
    raise HTTPException(400, "Install 'cliclick' (brew install cliclick)")

# Audio
@app.post("/audio/tts")
def audio_tts(req: TTSReq, _=Depends(require_auth)):
    voice = req.voice or "Samantha"
    rate = req.rate
    text = req.text or ""
    args = ["say", text]
    if voice: args += ["-v", voice]
    if rate: args += ["-r", str(rate)]
    subprocess.run(args, check=False)
    return {"ok": True}

@app.post("/audio/stt")
def audio_stt(req: STTReq, _=Depends(require_auth)):
    p = Path(req.path).expanduser()
    if not p.exists(): raise HTTPException(400, f"file not found: {p}")
    # prefer local whisper CLI if installed
    if not req.use_api and shutil.which("whisper"):
        outdir = Path("artifacts") / f"stt_{now_ts()}"; outdir.mkdir(exist_ok=True)
        cmd = ["whisper", str(p), "--task", "transcribe", "--output_dir", str(outdir)]
        if req.lang: cmd += ["--language", req.lang]
        subprocess.run(cmd, check=False)
        # find .txt
        txt = ""
        for f in outdir.glob("*.txt"):
            txt = f.read_text(encoding="utf-8"); break
        return {"ok": True, "text": txt, "artifact": f"/artifacts/{outdir.name}/"}
    # fallback to python whisper lib
    try:
        import whisper
        model = whisper.load_model("base")
        res = model.transcribe(str(p), language=req.lang)
        return {"ok": True, "text": res.get("text","")}
    except Exception as e:
        # fallback to OpenAI API if key present
        key = secrets_load().get("OPENAI_API_KEY")
        if not key:
            raise HTTPException(400, f"Install openai-whisper (pip) or set OPENAI_API_KEY to use API. Details: {e}")
        import requests
        files = {"file": (p.name, open(p, "rb"), "audio/mpeg")}
        data = {"model": "whisper-1"}
        if req.lang: data["language"] = req.lang
        headers = {"Authorization": f"Bearer {key}"}
        r = requests.post("https://api.openai.com/v1/audio/transcriptions", headers=headers, data=data, files=files, timeout=120)
        if r.status_code != 200:
            raise HTTPException(400, f"OpenAI STT failed: {r.text}")
        j = r.json()
        return {"ok": True, "text": j.get("text","")}

# Figma spec (same as v1, simplified)
FIGMA_SPEC = Path("figma_spec.json")
if not FIGMA_SPEC.exists():
    FIGMA_SPEC.write_text(json.dumps({
        "document": {"name":"Configurator"},
        "frames": [
            {"name":"Home","w":1440,"h":1024,"nodes":[
                {"type":"text","x":40,"y":40,"text":"Hello from Agent-OS Ultra v2","fontSize":32},
                {"type":"rect","x":40,"y":100,"w":300,"h":120,"fill":"#7047D6","corner":12}
            ]}
        ]
    }, indent=2), encoding="utf-8")

@app.get("/figma/spec")
def figma_spec_get(): return json.loads(FIGMA_SPEC.read_text(encoding="utf-8"))
@app.put("/figma/spec")
def figma_spec_put(spec: Dict[str,Any], _=Depends(require_auth)):
    FIGMA_SPEC.write_text(json.dumps(spec, ensure_ascii=False, indent=2), encoding="utf-8"); return {"ok": True}

# Deploy (same as v1)
class DeployCfg(BaseModel):
    host: str; user: str; key_path: Optional[str] = None; port: int = 22
    local_path: str = "./build"; remote_path: str = "~/site/public"; delete_remote: bool = False

@app.post("/deploy/rsync")
def deploy_rsync(cfg: DeployCfg, request: Request, _=Depends(require_auth)):
    require_approval("deploy/rsync", request)
    ssh_opt = ["-e", f"ssh -p {cfg.port}"] if not cfg.key_path else ["-e", f"ssh -i {shlex.quote(cfg.key_path)} -p {cfg.port}"]
    args = ["rsync","-az"] + (["--delete"] if cfg.delete_remote else []) + ssh_opt + [cfg.local_path, f"{cfg.user}@{cfg.host}:{cfg.remote_path}"]
    try:
        res = subprocess.run(" ".join(args), shell=True, capture_output=True, text=True, check=True)
        out = (res.stdout or res.stderr or "").strip(); return {"ok": True, "output": out}
    except subprocess.CalledProcessError as e:
        out = (e.stderr or e.stdout or str(e)).strip(); raise HTTPException(400, f"rsync failed: {out}")

@app.post("/deploy/sftp")
def deploy_sftp(cfg: DeployCfg, request: Request, _=Depends(require_auth)):
    require_approval("deploy/sftp", request)
    dest = f"{cfg.user}@{cfg.host}:{cfg.remote_path}"; key = ["-i", cfg.key_path] if cfg.key_path else []
    cmd = ["scp","-P", str(cfg.port), "-r"] + key + [cfg.local_path, dest]
    try:
        res = subprocess.run(cmd, capture_output=True, text=True, check=True); return {"ok": True, "output": (res.stdout or res.stderr or '').strip()}
    except subprocess.CalledProcessError as e:
        out = (e.stderr or e.stdout or str(e)).strip(); raise HTTPException(400, f"scp failed: {out}")

# AI gateway (minimal; same as v1)
from pydantic import BaseModel
from typing import Literal
import os, requests
from fastapi import HTTPException

class AIReq(BaseModel):
    provider: Literal["openai","anthropic","openrouter"] = "openai"
    model: str
    prompt: str
    max_tokens: int = 1024
    temperature: float = 0.2

@app.post("/ai/complete")
def ai_complete(req: AIReq, _=Depends(require_auth)):
    if req.provider == "openai":
        from openai import OpenAI
        key = os.getenv("OPENAI_API_KEY")
        if not key:
            raise HTTPException(400, "OPENAI_API_KEY not set")
        client = OpenAI(api_key=key)
        r = client.chat.completions.create(
            model=req.model,
            messages=[{"role":"user","content":req.prompt}],
            max_tokens=req.max_tokens,
            temperature=req.temperature
        )
        return {"ok": True, "text": r.choices[0].message.content}

    elif req.provider == "anthropic":
        import anthropic
        key = os.getenv("ANTHROPIC_API_KEY")
        if not key:
            raise HTTPException(400, "ANTHROPIC_API_KEY not set")
        client = anthropic.Anthropic(api_key=key)
        r = client.messages.create(
            model=req.model,
            max_tokens=req.max_tokens,
            messages=[{"role":"user","content":req.prompt}],
            temperature=req.temperature
        )
        # Склеим только текстовые блоки:
        text = "".join([b.text for b in r.content if getattr(b, "type", "") == "text"])
        return {"ok": True, "text": text}

    else:  # openrouter
        key = os.getenv("OPENROUTER_API_KEY")
        if not key:
            raise HTTPException(400, "OPENROUTER_API_KEY not set")
        headers = {"Authorization": f"Bearer {key}", "Content-Type": "application/json"}
        payload = {"model": req.model, "messages": [{"role":"user","content": req.prompt}]}
        resp = requests.post("https://openrouter.ai/api/v1/chat/completions",
                             json=payload, headers=headers, timeout=90)
        resp.raise_for_status()
        data = resp.json()
        return {"ok": True, "text": data["choices"][0]["message"]["content"]}

# Secrets & KV
@app.post("/secrets/set")
def secrets_set(key: str = Body(...), value: str = Body(...), _=Depends(require_auth)):
    s = secrets_load(); s[key] = value; secrets_save(s); return {"ok": True}
@app.get("/secrets/get")
def secrets_get(key: str, _=Depends(require_auth)):
    return {"ok": True, "value": secrets_load().get(key)}
@app.get("/secrets/list")
def secrets_list(_=Depends(require_auth)):
    return {"ok": True, "keys": list(secrets_load().keys())}

@app.post("/kv/set")
def kv_set(key: str = Body(...), value: Any = Body(...), _=Depends(require_auth)):
    kv = kv_load(); kv[key]=value; kv_save(kv); return {"ok": True}
@app.get("/kv/get")
def kv_get(key: str, _=Depends(require_auth)):
    return {"ok": True, "value": kv_load().get(key)}

# UI page
@app.get("/ui", response_class=HTMLResponse)
def ui_page():
    idx = Path("web/index.html")
    if idx.exists(): return idx.read_text(encoding="utf-8")
    return "<h1>Agent‑OS Ultra v2</h1><p>UI not found</p>"

# ----- OpenAPI YAML served statically via /actions (written by quickrun)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("server:app", host="127.0.0.1", port=PORT, reload=False)

# --- Modular OpenAPI packs (<=30 ops each)
from fastapi import HTTPException
from fastapi.openapi.utils import get_openapi
from copy import deepcopy

PACKS = {
    # <= ~15–20 операций — импортируем первым
    "core": [
        "/health",
        "/open_app", "/activate_app", "/open_url",
        "/run_shortcut", "/keystroke", "/keycode",
        "/clipboard/get", "/clipboard/set", "/clipboard/set_image",
        "/ai/complete",
        "/audio/tts", "/audio/stt",
        "/vision/locate_text", "/vision/click_at",
    ],

    # UI по AX (клики по лейблам/ролям), окна/Spaces
    "ui": [
        "/ui/find", "/ui/click", "/ui/type", "/ui/exists",
        "/windows/list", "/windows/move", "/windows/tile",
        "/spaces/switch",
    ],

    # Headless‑браузер и сбор данных
    "browser": [
        "/browser/open", "/browser/actions",
        "/browser/scrape", "/browser/crawl",
        "/browser/network_log", "/browser/session/import_cookies",
    ],

    # Дизайн/Figma (REST часть; редактирование — через плагин)
    "design": [
        "/figma/file", "/figma/export",
    ],

    # Интеграции: соцсети/мессенджеры
    "social": [
        "/vk/post", "/vk/upload_photo",
        "/telegram/send", "/slack/post",
    ],

    # Данные/таблицы/хранилища
    "data": [
        "/sheets/get", "/sheets/update",
        "/notion/query", "/airtable/upsert",
        "/storage/upload",
    ],

    # Dev/деплой/CICD
    "dev": [
        "/git/clone", "/git/status", "/git/commit", "/git/push",
        "/deploy/beget", "/deploy/vercel", "/deploy/netlify",
        "/db/migrate", "/db/seed",
    ],
}

@app.get("/openapi/pack/{name}.json")
def openapi_pack(name: str):
    if name not in PACKS:
        raise HTTPException(404, f"Unknown pack: {name}")
    base = app.openapi()  # готовая базовая спека
    allowed = set(PACKS[name])
    spec = deepcopy(base)
    spec["paths"] = {p: ops for p, ops in base.get("paths", {}).items() if p in allowed}
    spec["info"]["title"] = f"Agent OS – {name} pack"
    return spec
